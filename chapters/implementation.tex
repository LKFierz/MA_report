\chapter{preparation - Autonomous Landing Procedure}\label{chapter:core_implementation}


With the enhanced structure of the LSD output, having implemented a stereo camera as a low altitude alternative to SFM and after ensuring a correct ground truth comparison, the main contribution of this work could be faced: Bringing the visual landing site pipeline together with the autonomy framework in order to achieve reliable autonomous landing in unknown terrain.

This implementation can be split into the following parts:
\begin{itemize}
    \item Landing Site Heuristic
    \item Conceptual Behavior
    \item Behavior Tree Implementation
\end{itemize}



\section{Landing Site Heuristic}\label{subsubsec:LandingSiteHeuristic}

As mentioned in \cref{sec:LSproperties} the autonomy receives landing sites from LSD with the following properties:

\begin{itemize}
    \item Position
    \item Roughness
    \item Uncertainty
    \item Size
    \item Obstacle Altitude
\end{itemize}

From these properties the characteristics that comprise the final heuristic are:

\begin{itemize}
    \item Current Distance to Drone
    \item Roughness
    \item Uncertainty
    \item Size
    \item Verification Altitude
\end{itemize}

The final heuristic defining the quality of a landing site is in fact a square loss function:

\begin{equation}
    L_{LS} = w_{dist}L_{dist} + w_{rough}L_{rough} + w_{var}L_{var} + w_{size}L_{size} + w_{verAlt}L_{verAlt}
    \label{eq:loss_fct}
\end{equation}

\subsection{Current Distance to Drone - $L_{dist}$}
Well likely the single most important characteristic of an LSD-prefiltered\footnote[1]{Each received landing site has already undergone a threshold filtering regarding slope and roughness.} landing site. Each iteration the current distance to the drone's position is calculated for each retained landing site. The distance is then normalized by dividing it by the cruise altitude which is 100m. In practice there were easily enough landing sites found while moving to allow landing sites to fall off when being farther away than 100m.

\subsection{Roughness - $L_{rough}$}
%TODO

The roughness property is the unaltered roughness value received from LSD. It is already normalized and enters the loss function as it is. 

\subsection{Uncertainty - $L_{var}$}

The same holds for the uncertainty. It is already normalized by design and enters the loss function unaltered.

\subsection{Size - $L_{size}$}

Analogous to the roughness and uncertainty properties the size comes from the landing site detection directly. However unlike the two preceeding properties it is not normalized but simply denotes the metric radius of the largest circle of valid landing area that can be fit around a given landing site. This is achieved in LSD by performing a distance transform on the created landing site image.

In order to normalize this value the maximum landing site size is retained and each landing site's size is divided by it in order to achieve normalized size information.

Also as can be seen in \cref{eq:loss_fct}, the size contribution enters the loss function with a negative sign. This is due to the fact that compared to all other characteristics, the size defines a property that we would like to maximize.

\subsection{Verification Altitude - $L_{verAlt}$}

A site's verificaiton altitude is the smallest vertical distance between the drone and the landing site at which that site was (re-) detected. 

The verification altitude is a useful property because of numerous reasons.
\subsubsection{Further Indication of Certainty}
First of all similar to the uncertainty metric the verification altitude indicates how certain we can be about a detected landing site as spots detected at lower flight altitudes are more likely correct due to the reduced depth error. Even though it might seem overlapping with the uncertainty property in this regard, these two characteristics are quite complementary as the uncertainty takes OMG convergence and camera specifics into consideration while the verificaiton altitude is a purely location based metric.

\subsubsection{Landing Site Property Updates}
As the verification altitude yields a simple and good estimation of the trustworthiness of an incoming landing site, it can be used as a flag to know, when a landing site's properties should be updated. When a landing site is redetected with a verification altitude lower than the previously stored one, the algorithm trusts it more and alters the previously stored properties to the new ones received.

\subsubsection{Verification}

Continuously updating the verification altitude upon redetection allows us to determine the lowest altitute, at which a landing site was redetected. This information can be used to verify that a given site was considered a valid landing spot even at low altitudes. 

\section{Conceptual Behavior}

Bringing everything together and emphasizing landing aspects of an autonomous flight perspective, we arrive at the following procedure:

\subsection{Takeoff}

The necessary checks and initializations are performed. This includes the created mission waypoint plan, the ros-, as well as the mavros-connection setup with the initial setting of mavros parameters.

Then the drone takes off vertically until it reaches the first waypoint's target altitude.

During this phase the stereo camera feeds depth images into LSD until the laser range finder switches to SFM which results in a stop of depth supply as SFM does not detect depth during vertical motion.



\subsection{Prerequisite - Landing Site Handling}

Landing sites are constantly received by the autonomy's ROS connector which constitutes the ros interface with the landing site detector. The sites have to be processed in a separate thread. This is handled by a landing site manager (LSM) singleton class.

\subsubsection{Landing Site Manager}

The incoming landing sites are ranked according to a loss function(\ref{subsubsec:LandingSiteHeuristic}) and stored in a max-heap buffer in order to easily switch out the worst landing site for a new one at any given time.

\subsection{Transition into Landing}

During a mission the drone flies to different waypoints. During the lateral motion periods of these flights, the drone continuously processes the incoming landing sites using the LSM.

Once the last mission waypoint has been reached, the transition to the landing behavior occurs.

At first, 

\section{Behavior Tree Implementation}\label{subsec:behavior_tree}

As a mission is flown at 100m altitude we would like to verify it closer to the ground where we can be more certain about measured terrain.

To this end the drone moves laterally to a chosen landing site and then descends blindly to a certain verification altitude above that spot. We can do so safely as, yes, the initial landing site estimate from 100m altitude might not be a good choice, however as can be seen in \cref{eq:SFM_depth_error}, given an approximate baseline of 15m at 100m altitude with a focal length of 256 and an assumed subpixel disparity error of 0.5, the structure from motion algorithm yields depth measurements with an approximate depth error of 1.3m.

\begin{align}
    {\Delta z} &= \frac{z^2}{f  \cdot b}\Delta d\\
    {\Delta z} &= \frac{100m^2}{256  \cdot 15m}0.5 = 1.302m
    \label{eq:SFM_depth_error}
\end{align}

Therefore in the very worst case szenario of a depth error of 1.3m we are still safe when we descend to a verification altitude of 2.5m above a detected landing site. Avoiding SFM verification patterns at intermediate altitudes saves a tremendous amount of time and energy.

The verification is performed using the stereo camera(\ref{sec:StereoDepth}).



\subsection{Action Definition}
The final landing behavior is implemented in the form of a behavior tree which allows adaptive decision making.

The autonomy framework already defined the core control flow nodes as well as some of the action nodes required for the landing behavior. (\ref{subsec:setup:behavior_tree}) Hereafter displayed is a list of additional actions needed to be defined in this work. It should be noted, that they define individual actions and should not be a description of the entire behavior. For this consider \cref{subsec:behavior_tree}

\subsubsection{CheckLandingSite}

Simple utility action which checks whether any landing sites have been found by querying the LSM's landing site buffer length.

\subsubsection{ChangeAltitudeLSAction}

This action was implemented with the purpose to allow us to descend to a certain fixed altitude above a chosen landing site. The creation of another action for this purpose is simply a utility which let's us avoid having to pass a function pointer in the action defition as the arguments passed in a behavior tree are always evaluated at the time of the creation.


\subsubsection{GetClearAltitude}
Once a landing site has been chosen, the failsafe mechanism to go to that landing site is the following:

\begin{enumerate}
    \item Ascend to a safe altitude.
    \item Traverse laterally to the landing site's xy-position.
    \item Descend to the landing site or verification altitude.
\end{enumerate}

The question remains however, what the adequate clearing altitude is. The goal is to find an altitude high enough to fly safely without the risk of collision yet low enough as to not waste energy for the increased ascent / descent distances.

This is where the aforementioned obstacle altitude from \cref{subsec:obstacle_altitude} comes in. The obstacle altitude gives us an indication of the height to clear around the landing site. Therefore we can take this as the start altitude for the derivation.

As the DEM created by LSD covers only a limited area, the obstacle altitude is only an indication of the highest terrain present at the chosen landing site. The worst case szenario would be the detection of the landing site at the very edge of the DEM shortly before significantly higher terrain starts. Therefore one has to anticipate this case. 

In practice a safe altitude buffer is implemented by assuming a worst case 45-degree incline of the terrain starting immediately at the landing site. Thus the necessary clearing altitude can be derived by linearly interpolating the final value from the initial obstacle altitude and the distance between the drone and the landing site which needs to be covered.

In the end to not ascend to excessive heights, the clearing altitude is capped at a predetermined, terrain-based failsafe altitude

\begin{align}
    z_{\text{clear}} &= z_{\text{obst.}} + z_{\text{buffer}} + d_{\text{drone-LS}}\\
    z_{\text{clear}} &= \text{min}\left(z_{\text{clear}}, z_{\text{failsafe}}\right)
\end{align}
Above we can see the derivation of the clearing altitude where $z_{\text{clear}}$ defines the clearing altitude, $z_{\text{buffer}}$ a safety buffer on top of the obstacle altitude, $d_{\text{drone-LS}}$ the drone's current distance to the site and $z_{\text{failsafe}}$ the failsafe altitude at which the clearing altitude is capped.


\subsubsection{GetLandingSiteAction}

Upon leaving the mission state and entering the landing state, the autonomy attempts to select the currently best landing site according to the in \cref{subsubsec:LandingSiteHeuristic} introduced loss function.

This is done by using the landing site manager in order to rank the landing sites in an ascending sorted list (as opposed to a max-heap) and selecting the first entry with the lowest loss.

The selected landing site is then stored in a blackboard interface which allows easy data sharing between all the actions within the autonomy.

In the end the GetLandingSiteAction invokes the GetClearAltitude action to also store the clear altitude on the blackboard. This is used by the NavigateToWaypointAction to move to that site on the derived safe altitude.

\subsubsection{LandingSiteVerificationAction}

Once a landing site is chosen, we have to make sure it's a good spot to land before attempting to do so. 

The LandingSiteVerificationAction does this by using the verification altitude property of a given landing site:

When a landing site is detected by SFM at 100m altitude it will be overwritten when redetected at 2.5m above the ground. 

This is the mechanism exploited in order to verify a landing site. The drone hovers above the landing site for a predetermined duration in place and attempts to redetect the chosen landing site. This means that the LSM continuously processing incoming landing sites and if one is close enough to an existing one, it is considered a redetection. In that case, the landing site is verified and the landing action can be triggered.

In case of verification failure, the landing site is not only removed but actively banned in order to prevent future false positives at high altitudes.

Also as previously mentioned the verification hovering at low altitudes leads most probably to the detection of close by landing sites. This is arguably as important as the verification of a previous landing site as it yields a good candidate in close proximity. In practice, it turned out,  it is equally likely to verify a landing site as it is to not verify one but detect a high quality landing site close by.

\subsubsection{LandingSiteSearchAction}

The previously described actions are core implementations of the nominal behavior in the landing sequence. However what happens when no landing sites are found, either through fault of the landing site detection setup or due to really unfavorable terrain?

The most intuitive answer seems a good idea - simply look further for a site. The technical implementation of this task at high altitudes requires the detection by SFM and therefore lateral motion. So an easy solution is to fly a pattern at a new location with the exact same landing site handling procedure as in the nominal case.

The LandingSiteSearchAction implements this through a predefined rectangle of waypoints which are flown through. This sub-mission is cancelled upon detecting a single landing site. In that case the usual landing procedure is continued.

\subsubsection{GetNextPatternCenterWPAction}

In case of failure when looking for additional landing sites, the adaptive procedure is to simply move to a new location and try anew. 

The drone picks a random position around the final mission waypoint, flies there and again moves laterally in a rectangle shape in the hope of detecting landing sites.

Note: This procedure is repeated a fixed number of times using the retry control node described in \cref{subsubsec:decorator_nodes}. Optimally however, this would be performed as long as the battery state permits it. 

